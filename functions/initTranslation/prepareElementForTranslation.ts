import { LanguageVariantModels } from '@kontent-ai/management-sdk';
import { NormalizedContentType, NormalizedContentTypeElementType } from './loadContentType';
import { createTranslationKey } from './translationKey';

export const prepareDataForTranslation = (variant: LanguageVariantModels.ContentItemLanguageVariant, contentType: NormalizedContentType): Readonly<Record<string, string>> =>
  Object.fromEntries(
    variant.elements
      .map(element => [contentType.elements.find(el => el.id === element.element.id)?.type, element] as const)
      .filter(guardProperty(0, isTranslatedElement))
      .map(([type, element]) => {
      switch (type) {
        // case 'asset':
        // case 'custom':
        // case 'number':
        // case 'multiple_choice':
        // case 'taxonomy':
        // case 'date_time':
        //   return []; // don't translate
        case 'url_slug':
          return [createTranslationKey(element.element.id || '', variant.item.id || '', type, [element.mode || 'autogenerated']), (element.value as string | undefined) || ''] as const;
        case 'text':
          return [createTranslationKey(element.element.id || '', variant.item.id || '', type, []), (element.value as string | undefined) || ''] as const;
        // case 'modular_content':
        //   return []; // ???
        // case 'rich_text':
        //   return []; // TODO: process it somehow
        // default:
        //   throw new Error(`Unknown element type ${type}`);
      }
    }),
  );

const translatedElementType = {
  text: null,
  url_slug: null,
  // modular_content: null,
};

export type TranslatedElementType = keyof typeof translatedElementType;

const isTranslatedElement = (elementType: NormalizedContentTypeElementType | undefined): elementType is TranslatedElementType =>
  (Object.keys(translatedElementType) as string[]).includes(elementType || '');

const guardProperty = <PropName extends string | number, GuardIn, GuardOut extends GuardIn>(propName: PropName, guard: (arg: GuardIn) => arg is GuardOut) =>
  <Value extends Readonly<Record<PropName, GuardIn>>>(value: Value): value is Value & Readonly<Record<PropName, GuardOut>> =>
    propName in value && guard(value[propName]);
